# 一小时总结 -- JVM 虚拟机及问题解决

- 原理性知识
	- 整体：JVM 规范要求
		- 数据类型及字节码
	- 内存管理：JVM 的内存分类及管理方式
		- JVM 的内存分类
		- JVM 的 GC 算法和各 GC 特点；
	- 类加载和管理：
		- JVM 的类加载过程；
		- 双亲委派模型和 classloader
	- 运行过程：
		- JVM 的程序运行过程
		- 线程和栈内存、栈帧本地变量表；
		- 一个对象占用的内存空间如何计算；
	- 效率知识：
		- synchronized 关键字的实现；
		- 偏向锁、自旋锁、轻量级锁和重量级锁；
- 实际应用：
	- JVM 的分类；
	- 对内存分析工具：jmap；
	- 栈分析工具：jstack；
	- 场景：死循环问题定位和分析；
	- 场景：OOM 问题分析；
	- 场景：基于火焰图的性能优化； 

# 原理性知识

## 整体：JVM 规范要求

《Java 虚拟机规范》规定了一个 JVM 的逻辑结构和各结构应该实现的功能；

JVM 规范在下列方面做了实现指导和要求：

- 内存分类：JVM 需要实现 堆内存、栈内存、本地方法区、程序计数器；
	- 内存管理：实现对堆内存的自动化内存管理；
- 类加载和验证：规定某个类应该如何被加载和验证某个是否是合规的 class 文件；
- 字节码：规定了 class 文件的字节码类型以及 JVM 应该如何解析运行字节码指令；
	- 数据类型：规定了每个字节码的对应的数据类型和数据类型转换规则；

## 内存管理：JVM 的内存分类及管理方式

- JVM 及实现的内存可分为线程私有和线程共享的内存；
	- 线程私有的内存：这里的数据不需要加锁没有多线程竞争风险；
	- 线程共有内存：要注意数据是否真的被共享，如线程私有对象但是要放在共享内存中，但是其他线程没有此对象引用是无法访问此对象数据，因此无需同步保护，其他共享内存数据需要注意加锁；
- 线下私有代码：
	- 栈内存：每个线程对应建立一个栈，理论上每次 new 一个 thread 最少要分配 1M 的栈内存空间；
	- 程序计数器：指示当前线程
- 线程共享内存：
	- 堆内存：此内存用来分配 java 对象的实例数据，此内存 JVM 规范要求比必须实现自动化内存管理，即实现 GC ；

### JVM 的 GC 算法和各 GC 特点；

#### 基础算法：

- 根搜索算法：以图的搜索算法为基础，选择一系列肯定是存活的对象为基础开始搜索这些对象引用的对象标记为存活对象，剩下未标记的则为待回收对象。
	- 根对象的确定：原则是回收了就对程序产生影响的对象；
	- 栈空间引用的对象：表示方法还可能使用。？？？？

#### 回收算法

- 标记删除：也叫标记清除，第一轮标记对象是否存活，第二轮直接回收未存活对象的内存，算法简单，执行效率高，但是会产生碎片化的内存空间；
- 标记复制：将内存分为两个部分，使用部分和空闲部分，第一轮标记对象是否存活，第二轮将存活对象复制到空间空间，然后将当前活动空间标记为空闲空间。算法执行效率还不错，解决了空间碎片化问题，GC 后可以活动一些大的连续的内存空间，但是最大问题是有很大的内存浪费；
- 标记整理：在复制算法基础上，第一轮标记，第二轮把存活对象向一端做压缩对齐。算法效率不如复制算法效率，但是可以避免到空间浪费。

### 分代思路和算法：

- 基础：对象的存活周期是不同的，大概可分为：
	- 迅速死亡类：有些对象朝生夕灭，可能在一个方法结束后对象就要被回收；
	- 基本不死亡：对象创建后要存活很长时间，如单例对象或某个任务启动后建立直到任务结束后才死亡；
	- 永久不思维：如类对象基本上装载后就不会死亡
- 年龄：上面的对象属于哪种类型可以通过对象标记年龄，每轮存活标记则年龄+1；
- 分代：根据对象年龄，将不同年代的对象换分到不同内存中选择合适的 GC 算法收益更大，甚至不同代的内存回收频率不同；
	- 新生代内存：堆内存的一部分，GC 频率最高，对象创建销毁最频繁的内存，新 new 的对象都在这块儿内存；
	- 老年代内存：堆内存的一部分，GC 频率较低（不代表不 GC），对象创建后很长时间都存活，低频的回收接口；
	- 永久代内存：JDK 1.8 以前就是老年代内存的一部分，JDK 1.8 后移除永久代改用元数据区，这部分内存基本上不做 GC；
- MonitorGC：对新生代执行 GC 的过程；
- FullGC：对整个堆执行 GC 的过程，容易产生 STW 问题；

### 收集器和 GC 算法

- GC 算法：给出如何回收内存的一种思路和方案；
- 收集器：GC 算法的实现，为了让 JVM GC 运行最优化，收集器可能会动态的选择不同 GC 算法；

#### CMS 和 G1 收集器

- CMS：？？？？
- G1：Grabage First，这个彻底革新堆内存布局，把堆内存划分为若干个 region，回收时先扫描标记所有 region 这样可以知道每个 region 的对象状态，然后集中目标回收那些大部分对象都会思维的对象。G1 收集器的 STW 是可预测和可配置的，而且可以并行运行，效率不错。

## 类加载和管理

JVM 的类加载可分为：

- 加载：将二进制文件加载到内存中；
- 验证：验证二进制文件是否是一个合格的 class 文件；
- 链接：分析出 class 需要 import 的文件，然后也把他们加载并验证；
- 初始化：初始化类对象；

以上整个过程使用：classloader 完成，classloader 采用双亲委派模型设计；

### 双亲委派模型

classloader 被划分为多种类型，每种类型的 classloader 会加载不同目录下的 jar。这样可以避免全限定名的类冲突和覆盖问题。

- JVM 判断类相同：class 的 全限定名相同并且是同一个类加载器加载的。
- classloader 分类：
	- 启动类加载器：bootstrap classloader ，JVM 默认实现（一般是 C++）和提供的，加载 jvm 的 lib 目录下的基础类，如 rt.jar（包含 java.lang/java.util 包）
	- 扩展类加载器：external classloader ，java 实现，用来加载 system.getProperty("java.ext") 指定的目录下的 jar 包；
	- 应用类加载器：app classloader，加载我们工程使用的项目类；

#### 双亲委派过程

- 需要加载类：调用我们的 classloader，一般继承自 app classloader，然后我们的 classloader 询问 app classloader 它是否能加载（或加载过）此类。
- 汇报递进：app classloader 会询问它的上级 external classloader，external classloader 同理去问 bootstrap classloader；
- 确定谁来加载：所有上级都不加载目标类则自己来执行类加载；

##### 类验证

- 校验前几个字节是否为：COFE；
- 校验完整性等内容；

##### 初始化

- 先初始化父类，然后是子类，故我们看到的代码顺序是：
	- 父类静态常量，静态代码块儿，子类静态常量，子类静态代码块儿；
	- 父类构造方法，子类构造方法；
	- 父类类变量，子类类变量；‘’

	
## 运行过程
### JVM 的程序运行过程

JVM 被称为基于栈的虚拟机，其执行过程很好模拟了 CPU 的方法执行，方法执行过程的本质还是出栈入栈，方法的执行逻辑根据字节码指令完成，字节码指令就是 JVM 建立一套跨 CPU 平台的指令集。方法的执行要分为几个部分：

- 分配线程建立执行栈，执行方法；
- 实现方法的调用及返回，实现方法的参数传递；
- 为对象分配内存，管理对象生命周期；
- 执行指令集，确认指令集的变量类型；
- 实现多线程调用，实现共享资源的代码保护和内存可见性支持；

### 分配线程建立执行栈，执行方法

JVM 为每个线程都会建立一个栈空间，栈空间是线程私有空间，两个内存之间的栈空间互不影响。栈空间类似内核为每个进程（线程）分配的文件句柄。

- 栈帧：栈空间上面的基础数据结构，每个栈帧代表了一个方法调用，方法的调用本质就是栈帧的 pop、push；
- 空间占用：每个 Java 线程都会对应一个操作系统本地线程，Linux 内核中每个线程都会分配一个文件句柄，其本质是一个轻量级线程。每个 Java 线程约占用 1M 的内存空间。JVM 本质上是一个 C++ 构成的程序进程，每个进程可用空间在 32 位和 64 位内核中是固定的，假设它为 N G，那么分配给堆内存的空间越大，栈空间也就越小 N - 堆内存空间，这样可建立的线程数越小。
- 可建立线程数：具体数值要看 JDK 版本（1.7 or 1.8 ，32 位 or 64 位）、JVM 的启动参数（-xms，-ms 等）、操作系统版本（64、32）。一般经验来说下面的配置可建立线程数在 8、9 千左右。
	- linux 64，4C、8G；
	- JDK 1.8 64，堆 4G；
- 建议线程数：建立过多的线程并不会换来效率的极大提升，核心线程数：CPU 核数 * 2 效率不错。

#### 实现方法的调用及返回，实现方法的参数传递

- 运行时绑定：Java 实现多态的方式，在方法？？？？
- 方法调用：确定好要调用方法所在类（本质是找到其方法字节码）后，构建一个栈帧，把栈帧入栈，栈顶活动栈帧即为当前方法，方法执行时修改程序计数器位置指明当前方法执行到的字节码。
- 栈帧：
	- 本地变量表：大小在 java 文件编译为 class 文件时就已经确定了，避免了动态开辟内存的麻烦；
	- 程序计数器：每个栈帧一个。
	
## 效率知识

### synchronized 关键字的实现

> synchronized 是基于管程思想实现的。每个 synchronized 对应了一个 monitor ，对应的字节码是 monitorenter 和 monitorexit；同步原语提供了对临界资源的保护，保证了只能有一个线程运行临界区内代码，这样从而保证了只能有一个线程修改共享数据。

- monitor：通过管程思想实现的加锁；
- 临界区：会产生共享数据操作的代码区，通过对临界区的保护就有实现对共享资源的保护；
- 优化：synchronized 在 jdk 1.6 之前是仅通过管程实现，JDK 1.6 JVM 进行了锁消除、偏向锁、自旋锁；

#### 管程 -- monitor


> monitor ？？？？ 的本质其实就是 OS 的 mutex 锁。使用 monitor 实现了 mutex 的可重入性。
直接使用 mutex 来编程实际上要关注的细节点很多，如释放次数不能大于加锁次数，同一个线程还要实现可重入性，monitor 把上面这些都实现了。从而让锁的实现变的简单。
> 这里还需要查询资料再深入理解。

- 可重入性：同一个线程获得了 synchronized 的锁，那他对这个锁的调用具备可重入性，不需要重新竞争即可进入临界区；
- 本质：monitor 的本质是通过 mutex 实现的；
- 对象头：每个对象关联了一个 monitor ；
- 对象头的意义：某个 monitor 被哪个 thread 持有的，两个 thread 是否要竞争一个 monitor ，总要有一个地方记录这个关联，对象上记录这个信息最合适；


### 偏向锁、自旋锁、轻量级锁和重量级锁；	

- 锁消除：JVM 判断没有对共享资源做操作，就会不加锁，自动消除锁；
- 偏向锁：线程持有一个对象锁后，会修改这个对象头的 markcode 状态（好像是 00），锁本身是可重入的，所以只要没有其他线程来竞争锁，这个状态跟无锁是一样的。
- 轻量级锁：如果有其他线程竞争了一个对象锁，那么 JVM 会修改这个对象头的 markcode 状态（好像是 01），表示这个锁已经被竞争了。这样没有拿到锁的线程进行 while 的空转，称为自旋；
- 锁自选：线程不会被挂起，而是做 while(true){check(); cnt++} 这样的空转，当空转一定次数后还无法拿到锁则升级为重量级锁，线程要被挂起了；
- 锁自选的优势：大部分应用线程的锁释放的都很快，用空转形式，线程直接拿到锁，对线程来说，它感觉到的只是拿锁慢了点，并不是竞争了锁，但是如果让线程感知它要竞争锁，那么就要通过操作系统的 内核调用，从用户态陷入内核态，进行上下文切换。牺牲一点点 cpu 运行时间避免到更大的内核切换，这是值得的。
- 重量级锁：就是升级到 mutex 的竞争过程中。
- 可否回退：竞争一旦产生就不能回退，不能假设后面不竞争了，那样做效率反而低。

> 还需要再深入理解理解 mutex 和 monitor。

##### JVM 如何判断锁可消除

> 具体实现忘记了，需要好好再学学，如果自己来实现思路：
> 
> - 方法仅访问 栈空间数据，那么就没有线程共享资源；
> - 方法访问了堆内存，但是这个堆的对象的引用仅有它的线程栈的引用；
> 
> 

## 实际应用
### JVM 的分类


### 栈分析工具：jstack

- 用法：jstack <pid> 
- 目的：导出 JVM 的线程信息，可以看到 Thread 的状态（Waiting、Blocking、Running 等）；
- 本质：格式化输出了 JVM 的栈空间、程序计数器数据；

### 对内存分析工具：jmap 

- 用法：jmap <pid> <dump_file_name>
- 目的：导出 JVM 的堆内存数据，可以看到有哪些对象各自在哪个代中；

### 场景：死循环问题定位和分析

- 现象：CPU 跑满，不对外服务，请求 hang 住；
- 猜测：本质是某个线程一直跑不回归线程池，不服务下一个任务。
	- 可能代码 Bug 点：有死循环代码，while、for 出不来，
- 定位：用 jstack 导出栈空间，找出 running 状态的 thread，找到它运行的方法，分析对应代码状态。

### 场景：OOM 问题分析；


### 场景：频繁 Full GC；

- 现象：服务开机一段时间后吞吐量开始下降，gc.log 显示频繁的 full gc；
- 猜测：频繁 fullgc 表示老年代内存不够了，要找到为什么 老年代内存不够；
	- 老年代太小：程序有很多要晋升到老年代的对象，但是老年代太小，导致 JVM 进程前先打扫屋子；
	- 新生代太小：当新生代内存不够的时候会临时占用老年代内存，回收的时候要做 fullgc；
	- 产生了 OOM：
	- 有大对象：大对象是占用内存很大的如 Image 对象，这样的对象可能直接进入老年代；
	- 程序到性能瓶颈了：程序用内存缓冲过多，CPU 没满，但是内存已经用满了。
- 定位：
	- 先分析 gc.log ；
		- 如果每次 fullgc 后老年代没降低，那么就要看下为什么不回收，是否有 OOM 是否有大对象；
		- 如果每次 fullgc 后老年代内存回收很多，那么要考虑是否年轻代内存太小，调整 JVM 参数，调大堆内存，调大年轻代内存；
		- 如果分析没有 OOM、没有大对象，老年代空间不够用，那么考虑调堆内存，调大老年代内存；

### 场景：JVM 性能优化思路

> JVM 性能优化是个主动性行为，要明白自己的优化目标为什么要去优化它。

- 时机：代码没有 Bug，没有 OOM，但是 JVM 频繁的做 FullGC；
- 方法：主要是调整 JVM 的启动参数：
	- 采用 -server 的 gc 算法；
	- 调大 堆内存 xm、xs；
	- 调整老年代和新生代，（老的官方建议是：新生代占堆内存的 3/8 比较合适）

### 场景：火焰图的使用
